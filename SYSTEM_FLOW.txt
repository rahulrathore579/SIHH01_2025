================================================================================
                    PLANT DISEASE DETECTION SYSTEM - COMPLETE FLOW
================================================================================

ðŸŒ± SYSTEM OVERVIEW
==================
PC Master Controller (AI & Decision Maker) + Pi Slave Controller (Actuator Only)
Complete workflow from image capture to sprinkler control

ðŸ“‹ SETUP FLOW
=============

1. PC MASTER SETUP
   â”œâ”€â”€ Navigate to pc_server directory
   â”œâ”€â”€ Run: chmod +x start_pc_master.sh
   â”œâ”€â”€ Run: ./start_pc_master.sh
   â”œâ”€â”€ Script creates virtual environment
   â”œâ”€â”€ Script installs dependencies
   â”œâ”€â”€ Script starts Flask server on port 5000
   â””â”€â”€ Web UI available at http://localhost:5000

2. PI SLAVE SETUP
   â”œâ”€â”€ Navigate to pi_project directory
   â”œâ”€â”€ Run: chmod +x start_pi_slave.sh
   â”œâ”€â”€ Run: ./start_pi_slave.sh
   â”œâ”€â”€ Script checks if running on Raspberry Pi
   â”œâ”€â”€ Script creates virtual environment
   â”œâ”€â”€ Script installs dependencies
   â”œâ”€â”€ Script starts Flask API on port 5001
   â””â”€â”€ Pi API available at http://PI_IP:5001

3. HARDWARE CONNECTION
   â”œâ”€â”€ Connect camera to PC
   â”œâ”€â”€ Connect sprinkler to Pi GPIO pin 17
   â”œâ”€â”€ Ensure both devices on same network
   â””â”€â”€ Verify Pi IP address in PC configuration

ðŸ”„ OPERATIONAL FLOW
===================

PHASE 1: SYSTEM INITIALIZATION
------------------------------
1. PC Master Controller starts
   â”œâ”€â”€ Flask server initializes on port 5000
   â”œâ”€â”€ Camera system ready but not active
   â”œâ”€â”€ Gemini AI API configured
   â”œâ”€â”€ Pi API URL configured: http://10.203.228.217:5001/sprinkle
   â””â”€â”€ Web UI loads at http://localhost:5000

2. Pi Slave Controller starts
   â”œâ”€â”€ Flask API server initializes on port 5001
   â”œâ”€â”€ GPIO pin 17 configured for sprinkler control
   â”œâ”€â”€ Sprinkler set to LOW (off) state
   â”œâ”€â”€ Statistics counters initialized
   â””â”€â”€ Ready to receive commands from PC

3. Connection Verification
   â”œâ”€â”€ PC tests Pi connection via /api/test_pi_connection
   â”œâ”€â”€ Pi responds with health status
   â”œâ”€â”€ Connection status displayed in web UI
   â””â”€â”€ System ready for operation

PHASE 2: USER INTERACTION
-------------------------
1. User opens web browser
   â”œâ”€â”€ Navigate to http://localhost:5000
   â”œâ”€â”€ Web UI displays system status
   â”œâ”€â”€ Camera status: "Camera not started"
   â”œâ”€â”€ Pi connection status: "Connected" or "Failed"
   â””â”€â”€ Control buttons available

2. User starts camera
   â”œâ”€â”€ Click "Start Camera" button
   â”œâ”€â”€ PC sends POST to /api/start_camera
   â”œâ”€â”€ OpenCV initializes camera (device 0)
   â”œâ”€â”€ Camera properties set: 640x480, 15 FPS
   â”œâ”€â”€ Camera status updates to "Running"
   â””â”€â”€ Camera ready for image capture

PHASE 3: DISEASE DETECTION CYCLE
--------------------------------
1. User triggers detection
   â”œâ”€â”€ Click "Capture, Detect & Control Pi" button
   â”œâ”€â”€ Button disabled to prevent multiple requests
   â”œâ”€â”€ Status updates to "Capturing image and detecting disease..."
   â””â”€â”€ PC sends POST to /api/capture_and_detect

2. Image Capture (PC)
   â”œâ”€â”€ OpenCV captures frame from camera
   â”œâ”€â”€ Image saved as temporary file: capture_TIMESTAMP.jpg
   â”œâ”€â”€ File saved in temp/ directory
   â””â”€â”€ Image ready for AI processing

3. AI Disease Detection (PC)
   â”œâ”€â”€ PC calls detect_disease() function
   â”œâ”€â”€ Image sent to Google Gemini 2.0 Flash API
   â”œâ”€â”€ AI analyzes plant leaf image
   â”œâ”€â”€ Returns: disease type, severity percentage (0-100%)
   â””â”€â”€ Processing time: 2-5 seconds

4. Decision Making (PC)
   â”œâ”€â”€ PC evaluates severity against thresholds:
   â”‚   â”œâ”€â”€ 0-30%: Healthy â†’ action="off", duration=0
   â”‚   â”œâ”€â”€ 30-70%: Low disease â†’ action="on", duration=2000ms
   â”‚   â””â”€â”€ 70-100%: High disease â†’ action="on", duration=5000ms
   â”œâ”€â”€ Decision logic determines sprinkler action
   â””â”€â”€ Command payload prepared for Pi

5. Command Transmission (PC â†’ Pi)
   â”œâ”€â”€ PC sends HTTP POST to Pi API
   â”œâ”€â”€ URL: http://10.203.228.217:5001/sprinkle
   â”œâ”€â”€ Payload: {"action":"on","duration":5000}
   â”œâ”€â”€ Timeout: 10 seconds
   â””â”€â”€ PC waits for Pi response

PHASE 4: SPRINKLER CONTROL (Pi)
-------------------------------
1. Pi receives command
   â”œâ”€â”€ Pi Flask API receives POST on /sprinkle endpoint
   â”œâ”€â”€ JSON payload parsed: action and duration
   â”œâ”€â”€ Command logged: "ðŸ“¡ Received command: action=on, duration=5000ms"
   â”œâ”€â”€ Statistics updated: total_commands++
   â””â”€â”€ Pi prepares to control sprinkler

2. GPIO Control (Pi)
   â”œâ”€â”€ If action="on" and duration>0:
   â”‚   â”œâ”€â”€ GPIO pin 17 set to HIGH
   â”‚   â”œâ”€â”€ Sprinkler activates
   â”‚   â”œâ”€â”€ Pi waits for specified duration
   â”‚   â”œâ”€â”€ GPIO pin 17 set to LOW
   â”‚   â”œâ”€â”€ Sprinkler deactivates
   â”‚   â”œâ”€â”€ Statistics updated: total_sprays++, total_duration+=duration
   â”‚   â””â”€â”€ Log: "âœ… Sprinkler activated for 5000ms"
   â”‚
   â””â”€â”€ If action="off":
       â”œâ”€â”€ GPIO pin 17 set to LOW
       â”œâ”€â”€ Sprinkler remains off
       â””â”€â”€ Log: "ðŸŒ± Sprinkler kept off - Plant is healthy"

3. Response Generation (Pi)
   â”œâ”€â”€ Pi creates response JSON
   â”œâ”€â”€ Status: "sprinkled" or "off"
   â”œâ”€â”€ Duration: actual duration used
   â”œâ”€â”€ Timestamp: current time
   â””â”€â”€ Message: descriptive text

4. Response Transmission (Pi â†’ PC)
   â”œâ”€â”€ Pi sends HTTP response back to PC
   â”œâ”€â”€ Status code: 200 (success)
   â”œâ”€â”€ Response body: JSON with status and details
   â””â”€â”€ Pi continues listening for next command

PHASE 5: RESULT PROCESSING (PC)
-------------------------------
1. PC receives Pi response
   â”œâ”€â”€ PC receives HTTP response from Pi
   â”œâ”€â”€ Response parsed and validated
   â”œâ”€â”€ Connection status updated
   â””â”€â”€ Pi response stored for display

2. Result Storage (PC)
   â”œâ”€â”€ Detection result stored in memory
   â”œâ”€â”€ Action result stored in memory
   â”œâ”€â”€ Recent detections list updated
   â”œâ”€â”€ Recent actions list updated
   â””â”€â”€ Lists limited to last 50 entries

3. UI Update (PC)
   â”œâ”€â”€ Web UI refreshed with new data
   â”œâ”€â”€ Detection results table updated
   â”œâ”€â”€ Action history table updated
   â”œâ”€â”€ Last result displayed prominently
   â””â”€â”€ Status updated to "Detection complete"

4. Temporary File Cleanup (PC)
   â”œâ”€â”€ Temporary image file deleted
   â”œâ”€â”€ Disk space maintained
   â””â”€â”€ System ready for next cycle

PHASE 6: MONITORING & LOGGING
-----------------------------
1. PC Logging
   â”œâ”€â”€ Console output: "ðŸŒ± Complete Cycle: Diseased (High) - Disease: blight - Severity: 85.0% - Action: on - Duration: 5000ms"
   â”œâ”€â”€ Pi response logged: "ðŸ“¡ Pi Response: {'status': 'sprinkled', 'duration': 5000}"
   â”œâ”€â”€ Error handling for failed operations
   â””â”€â”€ System statistics maintained

2. Pi Logging
   â”œâ”€â”€ File logging: pi_slave.log
   â”œâ”€â”€ Console output for real-time monitoring
   â”œâ”€â”€ GPIO operation logs
   â”œâ”€â”€ API request/response logs
   â””â”€â”€ Statistics tracking

3. Web UI Monitoring
   â”œâ”€â”€ Real-time status updates
   â”œâ”€â”€ Detection history display
   â”œâ”€â”€ Action history display
   â”œâ”€â”€ Pi connection status
   â””â”€â”€ System health indicators

ðŸ”„ CONTINUOUS OPERATION
=======================

1. Auto-Refresh
   â”œâ”€â”€ Web UI refreshes every 30 seconds
   â”œâ”€â”€ Tables updated with latest data
   â”œâ”€â”€ Connection status monitored
   â””â”€â”€ System remains responsive

2. Error Handling
   â”œâ”€â”€ Camera errors: Fallback to error message
   â”œâ”€â”€ Pi connection errors: Retry mechanism
   â”œâ”€â”€ AI API errors: Mock detection fallback
   â”œâ”€â”€ GPIO errors: Emergency stop procedures
   â””â”€â”€ Network errors: Connection retry

3. System Maintenance
   â”œâ”€â”€ Memory management: Old results purged
   â”œâ”€â”€ File cleanup: Temporary files removed
   â”œâ”€â”€ Log rotation: Old logs archived
   â””â”€â”€ Performance monitoring: Response times tracked

ðŸ›‘ SHUTDOWN FLOW
================

1. PC Master Shutdown
   â”œâ”€â”€ User stops Flask server (Ctrl+C)
   â”œâ”€â”€ Camera resources released
   â”œâ”€â”€ Temporary files cleaned up
   â”œâ”€â”€ Memory cleared
   â””â”€â”€ System shutdown complete

2. Pi Slave Shutdown
   â”œâ”€â”€ User stops Flask server (Ctrl+C)
   â”œâ”€â”€ GPIO pin 17 set to LOW
   â”œâ”€â”€ GPIO cleanup performed
   â”œâ”€â”€ Logs finalized
   â””â”€â”€ System shutdown complete

ðŸ“Š DATA FLOW SUMMARY
====================

INPUT â†’ PROCESSING â†’ DECISION â†’ ACTION â†’ FEEDBACK

1. INPUT: Camera image capture (PC)
2. PROCESSING: AI disease detection (PC)
3. DECISION: Severity evaluation and action determination (PC)
4. ACTION: Sprinkler control via GPIO (Pi)
5. FEEDBACK: Response and result display (PC)

ðŸŒ± COMPLETE CYCLE TIME: ~3-7 seconds
- Image capture: 0.1 seconds
- AI processing: 2-5 seconds
- Pi communication: 0.1-1 second
- Sprinkler action: 0-5 seconds (based on duration)
- UI update: 0.1 seconds

================================================================================
                              END OF FLOW
================================================================================
